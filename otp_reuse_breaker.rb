require 'trie'

#monkeypatches
class String
	#string xor
	def ^(p2)
		if self.size < p2.size
			self.unpack("C*").zip(p2.unpack("C*")).map{|x1,x2| (x1^x2)}.pack("C*")
		else
			p2.unpack("C*").zip(self.unpack("C*")).map{|x1,x2| (x1^x2)}.pack("C*")
		end
	end
end

class Trie
	#small variation of search that returns the node
	def find(word)
		r = self.root
		word.each_char do |c|
			break if r.nil?
			r.walk!(c)
		end
		r
	end
end

class TrieNode
	#list the children of a node with letter in 'list'
	def children(list=255.times)
		list.each.map{|c| self.walk c.chr}.compact
	end

	#list all the pairs of childrens of 'self' and 'node' that xor'ed generate c
	def children_with(node,c)
		nsons = node.children
		res = []
		self.children.each do |n|
			if (k = nsons.find_all{|x| c.ord|0x20 == (x.state^n.state).ord|0x20})
				k.each do |k1|
					res << [n,k1]
				end
			end
		end
		res
	end
end

#problem class, encapsulate problem variables
class Problem
	@@punct = [' ',',',"\n",'.',':'] #USER: add extra punctuation here
	@@punct2 = @@punct.select{|x| x.size == 1}

	#xpunct[c] = l -> l is a list of pairs of punctuation s.t. l[i][0]^[i][1] = c
	@@xpunct = {}
	@@punct.each{|p1| @@punct.each{|p2| (@@xpunct[p1^p2] ||= []) << [p1,p2]} }

	#all non whitespace punctuation. Is a trie to make room for multi-char puncts.
	@@rest = Trie.new
	@@punct.select{|x| x != ' '}.each{|x| @@rest.add x}

	#open space for offline loading

	def initialize(c1,c2)
		@ctrie = Trie.read('ctrie.dict')
		@xt = c1^c2
		@c1 = c2
		@c2 = c2
	end

	def found(pl1,pl2)
		puts("\n### Found the texts:")
		puts("Text1: #{pl1}")
		puts("Text2: #{pl2}")
		puts("\n### Remarks:")
		puts(
				"The $ marks strings that are independent. They are surrounded by punctuation in\n"+
				 "such a manner that is not possible to unanbiguously arrange them.\n"+
				 "For instance, 'an eagle merry day'^'fat mens facebooks' == 'fat mens merry day'^ 'an eagle facebooks'\n\n")
		puts("The program is going to continue running to find all possible plaintexts that\n"+
				 "can generate the cyphertext. Some fun things should appear. To test running time\n"+
				 "uncomment the exit below")
		puts("#######################################################################################")
		#exit
	end

	def next_word(i,pl1,pl2,t)
		if @xt.size <= i
				found(pl1,pl2) #text ends after tww consecutive punctions on c1 and c2
			return
		end

		self.check_bound(i,pl1,pl2) if t.terminal?

		#test explicitly of the next pair could be generated by a space
		t.children([' '^@xt[i]]).each do |n|
			self.decode_chunks(i+1,@ctrie.root,n,pl1+' ',pl2+n.state)
			next_word(i+1,pl1+' ',pl2+n.state,n)
		end

		#could be generated by other puctuation?
		t.children_with(@@rest.root,@xt[i]).each do |n,p|
			if @xt.size == i+1
				found(pl1+p.state,pl2+n.state) #match ends with punctuation
				return
			end
			#after punctuation, we need a space(0x20).
			if (nn = n.walk(@xt[i+1]^0x20.chr))
				self.decode_chunks(i+2,
														@ctrie.root,
														nn,
														pl1+p.state+' ',
														pl2+n.state+nn.state)
				next_word(i+2,pl1+p.state+' ',pl2+n.state+nn.state,nn)
			end
		end
	end

	#if both words finish at once
	def check_bound(i,pl1,pl2)
		#xt[i] could be generated by xor of two punctuation?
		if (pchars = @@xpunct[@xt[i]])
			pchars.each do |p1,p2|
				#if it's two spaces, we don't have further information, go to start
				if p1 == ' ' && p2 == ' '
					self.start(i+1,i+1,pl1+p1,pl2+p2)
				end
				if @xt.size == i+1
					found(pl1+p1.state,pl2+p2.state)
					return
				end
				#if not a space, we can determine the next char following punct
				if p2 == ' '
					if (n = @ctrie.root.walk(@xt[i+1].downcase))
						decode_chunks(i+2,
													n,
													@ctrie.root,
													pl1+p1+' ',
													pl2+p2+@xt[i+1].downcase)
					end
				elsif p1 == ' '
					if (n = @ctrie.root.walk(@xt[i+1].downcase))
						decode_chunks(i+2,
													n,
													@ctrie.root,
													pl2+p1+@xt[i+1].downcase,
													pl1+p2+' ')
					end
				else
					if @xt[i+1] == "\x00"
						start(i+2,i+2,p1+p1+' ',pl2+p2+' ')
					end
				end
			end 
		end
	end

	#obs: a leaf node may have children
	def start(i,j,p1,p2)
		pl1	=  p1+'$'
		pl2	=  p2+'$'
		if @xt.size == i
			found(pl1,pl2)
			return
		end
		
		self.check_bound(i,pl1,pl2)
		decode_chunks(i,@ctrie.root,@ctrie.root,pl1,pl2)
	end
	
	#advance the pointer on both strings, checking if they belong to words in dict
	def decode_chunks(i,t1,t2,pl1,pl2)
		#The text ends on the middle of strings, truncated words
		if @xt.size <= i
			found(pl1,pl2)
			return
		end

		#t2 is the end of a word, start looking for another word
		if t2.terminal?
			self.next_word(i,pl2,pl1,t1)
		end

		#same with t1
		if t1.terminal?
			self.next_word(i,pl1,pl2,t2)
		end

		#advance pointer on t1 and t2
		t1.children_with(t2,@xt[i]).each do |n1,n2|
			self.decode_chunks(i+1,n1,n2,pl1+n1.state,pl2+n2.state)
		end
	end
end

#build dict and store it an a file for future use
def preprocess
	wordlist = File.open('wordlist').read.split
	ctrie = Trie.new
	wordlist.each do |w|
		ctrie.add w
	end
	puts 'finished ctrie'
	ctrie.save('ctrie.dict')
end

if __FILE__ == $0
	if 'prepare' ==  ARGV[0]
		preprocess
	elsif 'solve' == ARGV[0]
		p = Problem.new(File.open(ARGV[1]).read,File.open(ARGV[2]).read)
		p.start(0,0,'','')
	else
		puts 'ruby lab1.rb (prepare|solve) [file with ciphertext] [file with ciphertext]'
	end
end
